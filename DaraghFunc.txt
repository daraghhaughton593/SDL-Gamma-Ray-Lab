The following functions and docstrings were made by Daragh, and adapted by Caimin for use in the main analysis pipeline, 'gamma.py'.
Notes: 
i) As Caimin had to adapt some of these functions for the pipeline, separate docstrings were created in the pipeline by him to accurately reflect the functions use within the pipeline.
ii) Please see comments on GenAI use below. These were omitted from the primary pipeline in the interest of keeping it readable and neat. 
iii) The specific GenAI model used for assistance was: ChatGPT-4-Turbo
iv) Majority of pipeline adaptation was done by Caimin. I only added the error functions seen at the bottom.

def Gau1(data, a, b, c):
  """
  Function that calculates a Gaussian distribution function

  Parameters:
    data : array
      Points over which the Gaussian is evaluated
    a : float
      Amplitude of Gaussian (or peak height)
    b : float
      Centre of Gaussian (or peak centre)
    c : float
      Standard deviation of Gaussian (or peak spread)

  Return:
    array
      Gaussian function evaluated at data points
  """
  return (a * np.exp(-(data - b)**2 / (2 * c**2)))

#########

def line(x, a, b):
  """
  Parameters:
    x : array
      Points over which the linear function is evaluated
    a : float
      Slope of line
    b : float
      Intercept of line

   Return:
    array
      Linear function evaluated at data points
  """

  return a * x + b

#########

def paramsgenerator(counts, max, channel):
  """
  Function generates initial parameters to be sued in Gaussian peak fit

  Parameters:
  counts : array
    array of count values representing peak intensity
  max : float
    estimated position of the peak center (where peak height is max)
  channel : array
    array of channel values

  Return:
    fit_params : lmfit.Parameters
        Initial guesses for:
        - 'amp': amplitude (peak height), min = 0
        - 'cen': center position, +/- 20
        - 'wid': width (standard deviation), min = 0.5
    fwhm : float
        Full width at half maximum of the peak.
    sig : float
        Estimated standard deviation of the peak.
    
  """
  fit_params = lmfit.Parameters()
  amp = counts.max()
  center = max
  halfh = amp/2
  inds = np.where(counts >= halfh)[0]
  fwhm = channel.iloc[inds[-1]] - channel.iloc[inds[0]]
  sig = fwhm / 2.355

  fit_params.add('amp', value=amp, min = 0)
  fit_params.add('cen', value=center, min = center - 20, max = center + 20)
  fit_params.add('wid', value=sig, min = 0.5)

  return fit_params, fwhm, sig

#########

def myfunc(params, x, data):
  """
  Function calculates residuals between fitted Gaussian and input data

  Parameters:
  params : lmfit.Parameters
    Initial guesses for:
        - 'amp': amplitude (peak height), min = 0
        - 'cen': center position, +/- 20
        - 'wid': width (standard deviation), min = 0.5
  x : array
    data to be fitted using the Gau1 function

  data : array
    data values to be subtracted from the model to produced residuals

  Return:
    model - data : array
      Residuals between Gaussian and data
    
  """
    amp = params['amp'].value
    cen = params['cen'].value
    wid = params['wid'].value

    model = Gau1(x, amp, cen, wid)

    return model - data

#########

def peakfinder(file, guess, livetime, title, detname, T1, dec = None):
  """
    Function finds and fits a Gaussian peak to data in specified range of centre guess
    
    Parameters
    file : DataFrame
        DataFrame containing 'Channel' and 'Counts' columns
    guess : float
        Initial guess for the peak channel position
    livetime : float
        Measurement live time in seconds, used to convert counts to count rate
    title : str
        Isoptope name, for plot titling purposes
    detname : str
        Name of the detector used for measurement, again for plot titling and printing purposes
    T1 : float
        Region size either side of centre peak position which will be fitted
    dec : str, optional
        If 'Plot', displays a plot of the data and fit
        Defaults to None if no dec argument given
    
    Returns
    float
        Fitted peak centroid position in channel units

    Notes:
      Function optionally plots the channel vs counts spectrum, with the sliced region highlighted and the peak fit plotted.
  """
  channel = file.Channel
  counts = file.Counts

  #GenAI was used here. While finding the initial largest peak was fine, finding the second largest when the initial peak guess was unsuccessful was not as easy. As such, GenAI suggested counts.nlargest().index,   finding the top n peaks via this method, and selecting the second peak that is sufficienctly separated from the first (at least 5 channels away).

  n_peaks = 10
  top = counts.nlargest(n_peaks).index

  maxone = top[0]
  maxtwo = None

  for i in range(1, n_peaks):
      if abs(top[i] - maxone) >= 5:
          maxtwo = top[i]
          break

  if np.abs(maxone - guess) < 50:
    channelone = maxone
    print(f'Initial peak estimate good...{maxone}')

  elif np.abs(maxone - guess) > 50:
    channelone = maxtwo
    print(f'Initial peak estimate not good, going with second peak... {maxtwo}')

  else:
    print('Warning: Guesses bad - No estimation of Peak center')

  filtered1channel = (channel <= (channelone + T1)) & (channel >= (channelone - T1))
  filtered1channels = channel[filtered1channel]
  filteredonecounts = counts[filtered1channel]

  counts_plot = counts / livetime
  filtered1counts_plot = filteredonecounts / livetime
  ylabel = 'Count Rate (counts/s)'

  fit_params, fwhm1, sig1 = paramsgenerator(filtered1counts_plot, channelone, filtered1channels)

  # See https://lmfit.github.io/lmfit-py/fitting.html for more on below
  result = lmfit.minimize(myfunc, fit_params,
                          args=(filtered1channels.values, filtered1counts_plot.values))

  center1 = result.params['cen'].value
  amp1 = result.params['amp'].value
  wid1 = result.params['wid'].value

  gauss1 = Gau1(filtered1channels, amp1, center1, wid1)

  if dec == 'Plot':
    fig, ax = plt.subplots(figsize = (16, 6))

    ax.plot(channel, counts_plot)
    ax.scatter(filtered1channels, filtered1counts_plot, color = 'green', s = 30)

    ax.axvline(x = maxone, c = 'black', linestyle = ':', label=f'Max: {maxone}')
    ax.axvline(x = maxtwo, c = 'red', linestyle = ':', label=f'2nd: {maxtwo}')

    ax.plot(filtered1channels, gauss1, color = 'orange', label = 'Gaussian fit 1', linewidth = 2)

    ax.grid(True)
    ax.legend()
    ax.set_xlabel('Channel')
    ax.set_ylabel(ylabel)
    ax.set_title(f'Channel vs Count for {title} with {detname} detector')

    plt.tight_layout()
    plt.show()
  print(f'Peak centroid in channel: {center1:.3f}')
  return center1

#######

def calibcurvecalc(channels, guessenergies, detname):
  """
  Function calculates and plots calibration curve for detector

  Parameters:
    channels : array
        array of channel numbers corresponding to known peaks
    guessenergies : array
        array of known energies (in keV) corresponding to the channels
    detname : str
        Name of the detector being calibrated

  Return:
      gain : float
        The slope of the calibration plot

      offset : float
        The y-intercept of the calibration plot
    
  """
  gain, offset = np.polyfit(channels, guessenergies, 1)

  print(f'Gain: {gain:.3f}, Offset: {offset:.3f}')

  counter = 1
  for channel, energy in zip(channels, energies):
    calcenergy = channel * gain + offset
    resid = calcenergy  - energy

    print(f'Peak: {counter} | Residual: {resid}')
    counter += 1

  chanrange = np.linspace(0, max(channels) * 1.1, 1000)
  line = gain * chanrange + offset

  plt.figure(figsize=(6, 4))
  plt.scatter(channels, energies, color='red', s=50, zorder=5, label='Calibration points')
  plt.xlabel('Channels')
  plt.ylabel('Energies (keV)')
  plt.title(f'Calibration curve for detector: {detname}')
  plt.plot(chanrange, line, 'b-', linewidth=2, label=f'E = {gain:.3f}Ã—Ch + {offset:.3f}')
  plt.grid(True)
  plt.legend()

  return gain, offset


#######

def resfinder(file, T, guess, title, detname, gain, offset):
  """
  Function calculates energy resolution of a detector.

  Parameters
    file : DataFrame
        DataFrame containing 'Channel' and 'Counts' columns
    T : float
        Region size either side of centre peak position which will be fitted
    guess : float
        Initial guess for the peak channel position
    title : str
        Isoptope name, for plot titling purposes
    detname : str
        Name of the detector used for measurement, again for plot titling and printing purposes
    gain : float
      Gain factor from calibration step
    offset : float
      Energy offset factor from calibration step

  Returns:
    Res : float
      The energy resolution as a percentage
    fwhmkev : float
      The Full width at half maximum in keV
  
  """
  channel = file.Channel
  counts = file.Counts

  energy = channel * gain + offset

  n_peaks = 10

  #From previous use above: GenAI was used here. While finding the initial largest peak was fine, finding the second largest when the initial peak guess was unsuccessful was not as easy. As such, GenAI suggested    counts.nlargest().index, finding the top n peaks via this method, and selecting the second peak that is sufficienctly separated from the first (at least 5 channels away).

  top = counts.nlargest(n_peaks).index

  maxone = top[0]

  for i in range(1, n_peaks):
      if abs(top[i] - maxone) >= 5:
          maxtwo = top[i]
          break

  if np.abs(maxone - guess) < 50:
    channelone = maxone
    print('Initial peak estimate good...')

  elif np.abs(maxone - guess) > 50:
    channelone = maxtwo
    print('Initial peak estimate not good, going with second peak...')

  else:
    print('Warning: Guesses bad - No estimation of Peak center')

  print()

  filteredonechannel = (channel <= (channelone + T)) & (channel >= (channelone - T))
  filteredonecounts = counts[filteredonechannel]
  filteredonechannel = channel[filteredonechannel]

  fit_params, fwhm1, sig1 = paramsgenerator(filteredonecounts, channelone, filteredonechannel)

  # see https://lmfit.github.io/lmfit-py/fitting.html for more on below
  result = lmfit.minimize(myfunc, fit_params,
                          args=(filteredonechannel.values, filteredonecounts.values))

  print("Fit success:", result.success)
  print(f"Initial FWHM guess: {fwhm1:.3f} channels")

  center1 = result.params['cen'].value
  amp1 = result.params['amp'].value
  wid1 = result.params['wid'].value

  gauss1 = Gau1(filteredonechannel, amp1, center1, wid1)

  center1_idx = int(round(center1))

  energyatpeak1 = center1 * gain + offset

  fwhmkev = fwhm1 * gain

  print(f'Detector: {detname} | Isotope: {title}')

  print(f'Peak FWHM: {fwhmkev:.3f} | Peak Energy: {energyatpeak1:.3f}')

  Res = (fwhmkev / energyatpeak1) * 100
  print(f'Detector Resolution: {Res:.3f}%')

  return Res, fwhmkev

#######

def resvenergyplotter(fwhmlist, energieslist):
  """
  Function plots FWHM vs known energy values in keV

  Parameters:
    fwhmlist : list of floats
      list of FWHM values for different sources, in keV
    energieslist :  list of floats
      list of known peak energy values for different sources, in keV

  Return:
    None

  Notes:
    Function produces logarithmic plot of known peak energy vs FWHM, both in keV
  """
  if len(fwhmlist) == len(energieslist):
    plt.scatter(energies, fwhmlist)
    plt.xscale('log')
    plt.yscale('log')
    plt.xlabel('Known Energy Values (keV)')
    plt.ylabel('FWHM (keV)')
    plt.grid(True, which='both')
    plt.show()


#######

def absefffinder(counts, livetime, activity):
  """
  Function calculates detector absolute efficiency and uncertainties

  Paremeters:
  counts : array
    array of counts
  livetime : float
    measurement time in seconds
  activity : float
    Activity of source in bq

  Returns:
    abseff : float
      absolute efficiency of detector
    absefferr : float
      absolute efficiency error of detector

  Notes:
    Uses Poisson statistics for uncertainties
  """

  total_counts = float(counts.sum())
  lt = float(livetime)

  countrate = total_counts/lt
  countrateerr = np.sqrt(total_counts)/lt

  print(f'Count-rate = {countrate:.3f} +/- {countrateerr} cts/s')
  abseff = (countrate / (activity)) * 100
  absefferr = (countrateerr / (activity)) * 100
  print(f'Absolute Efficiency = {abseff * 100:.3f} +/- {absefferr * 100:.3f}%')
  print()

  return abseff, absefferr


#######

def filenumtoangle(filename):
  """
  Function extracts digits from a filename to determine angle

  Parameters:
    filename : str
      Filename string which should contain angle digits

  Return:
    str
      Numerical angle found in the filename
  """

  #GenAI was used here. Andrew suggested the use of Regex for finding numbers within strings, but GenAI was needed to provide specific direction for using it in finding numbers in strings. As such, GenAI provided the syntax for using Regex to find numbers within strings.

  angle = re.findall(r'\d+', filename)

  return angle

########

def effsvsenergies(absefficiencies, insefficiencies, energies):
  """
  Function produces a logarithmic plot of absolute and intrinsic efficiencies as a function of known energy value, with a polynomial fit fitted to intrinsic efficiency data

  Parameters:
    absefficiencies : array
      array of calculated absolute efficiency values for each energy
    insefficiencies : array
      array of calculated intrinsic efficiency values for each energy
    energies : array
      array of known peak energy values

  Return:
    None

  Notes:
    Function produces a logarithmic plot of absolute and intrinsic efficiency vs energy. Also plotted is a polynomial fit, fitted to the intrinsic efficiency vs energy data

    The polynomial used is a second order polynomial provided in the lab manual 
  """
  logenergy = np.log(energies)
  absefflog = np.log(absefficiencies)
  insefflog = np.log(insefficiencies)

  coeffs = np.polyfit(logenergy, insefflog, 2)

  # GenAI was used below. Initially, the function would plot the fit using the original energy values directly, but this produced a discontinuous curve. GenAI suggested using np.linspace, and the max and minimum known energy values to create a continuous energy space with lots of points, over which to fit the second order polynomial. This produced a smooth fit line. 

  espace = np.linspace(min(energies), max(energies), 100)
  effectivefit = coeffs[2] + coeffs[1]*np.log(espace) + coeffs[0]*(np.log(espace))**2
  expeffectfit = np.exp(effectivefit)

  plt.scatter(energies, absefficiencies, c = 'blue', label = 'Absolute efficiencies')
  plt.scatter(energies, insefficiencies, c = 'green', label = 'Absolute efficiencies')
  plt.plot(espace, expeffectfit, ':', color = 'red', label = 'Polyfit of intrinsic efficiencies')

  plt.xscale('log')
  plt.yscale('log')

  plt.xlabel('Energy Values (keV)')
  plt.ylabel('Efficiencies')
  plt.legend(loc = 'best')
  plt.grid(True, which='both')
  plt.show()

#########

def peakerrcalcer(peakE, centroiderrval, gain):
  """
  Function calculates and prints the peak energy and uncertainty

  Parameters:
    peakE : float
      Peak energy in keV
    centroiderrval : float
      uncertainty in centroid position in channel
    gain : float
      calibration value

  Returns:
    None
  """
  delE = centroiderrval * gain
  print(f'Peak energy =  {peakE:.3f} +/- {delE:.3f} (keV)')

#########

def RESerrorcalcer(R, sigval, sigerr, gain, peakE, peakEerr):
  """
    Function calculates and prints energy resolution and uncertainty.
    
    Parameters
    R : float
        Resolution (%)
    sigval : float
        Gaussian width sigma (channels)
    sigerr : float
        Uncertainty in sigma (channels)
    gain : float
        Energy calibration gain (keV/channel)
    peakE : float
        Peak energy in keV
    peakEerr : float
        Uncertainty in peak energy in keV
    
    Returns
    None
        Prints resolution with propagated uncertainty.
  """

  FWHM = sigval * 2.355
  delFWHM = sigerr * 2.355

  FWHMe = FWHM * gain
  FWHMeErr = delFWHM * gain

  delR = R * np.sqrt(((FWHMeErr/FWHMe)**2) + ((peakEerr/peakE)**2))

  print(f'Resolution = {R:.3f} +/- {delR:.3f}')

